<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mabinogi MML Converter (Mobile)</title>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --input-bg: #2c2c2c;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --accent-color: #0DB376;
            --danger-color: #ff5252;
            --border-radius: 16px;
            --spacing: 16px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            min-height: 100vh;
            padding-bottom: 80px;
            /* Space for bottom bar */
        }

        .app-container {
            width: 100%;
            max-width: 600px;
            /* Increased for tablets/large phones */
            padding: var(--spacing);
            margin: 0 auto;
            /* Center on larger screens */
        }

        /* Header */
        .header-section {
            margin-bottom: 24px;
        }

        .title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .section-label {
            font-size: 1.1rem;
            font-weight: bold;
        }

        /* Input Wrapper */
        .input-wrapper {
            position: relative;
            margin-bottom: 8px;
        }

        .input-wrapper input {
            width: 100%;
            background-color: var(--input-bg);
            border: none;
            border-radius: var(--border-radius);
            padding: 14px 40px 14px 16px;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .input-wrapper input:focus {
            outline: 1px solid var(--accent-color);
        }

        .clear-btn {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 8px;
            /* Larger touch target */
        }

        .composer-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        #composer-name {
            color: var(--text-primary);
            font-weight: bold;
        }

        /* Upload & Controls */
        .upload-section {
            background-color: var(--input-bg);
            border-radius: var(--border-radius);
            padding: 30px 20px;
            /* More vertical padding */
            text-align: center;
            cursor: pointer;
            margin-bottom: 20px;
            border: 2px dashed #444;
            transition: border-color 0.3s;
        }

        .upload-section:hover {
            border-color: var(--accent-color);
        }

        .controls-area {
            margin-bottom: 24px;
        }

        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
            align-items: center;
            flex-wrap: wrap;
            /* Allow wrapping on small screens */
        }

        .time-input,
        .bpm-input,
        .quant-select {
            background-color: var(--input-bg);
            border: none;
            border-radius: 12px;
            /* Softer corners */
            padding: 12px;
            color: var(--text-primary);
            flex: 1 1 80px;
            /* Grow, shrink, min-width */
            text-align: center;
            font-size: 1rem;
            min-width: 0;
            /* Fix flexbox overflow */
        }

        /* Specific adjustments for labels inside control rows */
        .control-row label {
            flex: 0 0 auto;
            /* Don't shrink labels */
            margin-right: 4px;
        }

        .action-btn {
            width: 100%;
            padding: 14px;
            border-radius: var(--border-radius);
            border: none;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.05rem;
            transition: transform 0.1s;
        }

        .action-btn:active {
            transform: scale(0.98);
        }

        .action-btn.primary {
            background-color: var(--accent-color);
            color: #fff;
        }

        .action-btn.secondary {
            background-color: #333;
            color: var(--text-primary);
        }

        /* MML Cards */
        .mml-card {
            background-color: transparent;
            margin-bottom: 20px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .icon-label {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speaker-icon {
            background-color: var(--accent-color);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-size: 0.9rem;
        }

        .part-name {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .char-count {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .card-body {
            position: relative;
        }

        .card-body textarea {
            width: 100%;
            height: 120px;
            /* Slightly taller */
            background-color: var(--input-bg);
            border: none;
            border-radius: var(--border-radius);
            padding: 16px;
            color: var(--text-primary);
            font-size: 0.95rem;
            /* Readable size */
            resize: none;
            line-height: 1.5;
            font-family: monospace;
            /* Better for code/MML */
        }

        .copy-btn {
            position: absolute;
            right: 12px;
            top: 12px;
            background: rgba(51, 51, 51, 0.8);
            border: 1px solid #444;
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 6px;
            backdrop-filter: blur(4px);
        }

        /* Bottom Bar */
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 16px;
            background: linear-gradient(to top, var(--bg-color) 90%, transparent);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: none;
            /* Let clicks pass through transparent area */
        }

        .bottom-content {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
            /* Re-enable clicks */
        }

        .ai-credit {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            opacity: 0.7;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .create-btn {
            width: 100%;
            max-width: 600px;
            background-color: var(--accent-color);
            color: #fff;
            border: none;
            border-radius: var(--border-radius);
            padding: 18px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0, 230, 118, 0.4);
            transition: transform 0.1s;
        }

        .create-btn:active {
            transform: scale(0.98);
        }

        .error-banner {
            background-color: rgba(255, 82, 82, 0.15);
            color: #ff8a80;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
            font-weight: bold;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 82, 82, 0.3);
        }

        /* Track List Items */
        .track-item {
            background: var(--card-bg);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            /* Wrap on small screens */
            gap: 8px;
        }

        .track-item span {
            font-size: 0.9rem;
            flex: 1 1 auto;
        }

        .track-item select {
            background: #333;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 6px;
            flex: 0 0 auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: white; z-index: 1000; flex-direction: column; justify-content: center; align-items: center;">
        <div class="spinner"
            style="border: 4px solid #00e676; border-top: 4px solid transparent; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px;">
        </div>
        <h3 id="loading-text">AI Î™®Îç∏ Î°úÎî© Ï§ë...</h3>
        <div
            style="width: 300px; height: 6px; background: #333; border-radius: 3px; margin-top: 15px; overflow: hidden;">
            <div id="progress-bar" style="width: 0%; height: 100%; background: #00e676; transition: width 0.3s ease;">
            </div>
        </div>
        <p id="progress-percent" style="margin-top: 5px; font-size: 0.9rem; color: #ccc;">0%</p>
    </div>

    <div class="app-container">
        <!-- Header / Title Input -->
        <div class="header-section">
            <div class="title-row">
                <label class="section-label">Í≥° Ï†úÎ™©</label>
            </div>
            <div class="input-wrapper">
                <input type="text" id="song-title" placeholder="Í≥° Ï†úÎ™©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.">
                <button class="clear-btn" onclick="document.getElementById('song-title').value=''">√ó</button>
            </div>
            <p class="composer-label">Made by <span id="composer-name">ÎûÄÎãò | ÏïåÎ¶¨ÏÇ¨</span></p>
        </div>

        <main>
            <!-- Upload Section -->
            <div class="upload-section" id="drop-zone">
                <div class="icon">üéµ</div>
                <p>MIDI / MP3 ÏóÖÎ°úÎìú</p>
                <input type="file" id="midi-input" accept=".mid,.midi,.mp3,.wav,.ogg,.mp4" style="display: none;">
                <p id="file-name" style="margin-top: 10px; font-size: 0.9rem; color: #00e676;"></p>
            </div>

            <!-- Time Range Inputs -->
            <div class="controls-area">
                <div class="control-row">
                    <input type="text" id="start-time" placeholder="00:00" class="time-input">
                    <span>~</span>
                    <input type="text" id="end-time" placeholder="00:00" class="time-input">
                </div>
                <button id="start-analysis-btn" class="action-btn secondary" style="margin-bottom: 15px;">Î∂ÑÏÑù ÏãúÏûë</button>
            </div>

            <!-- Controls Section (Hidden by default) -->
            <div id="controls" style="display: none;">
                <div class="control-row">
                    <input type="number" id="bpm-input" value="120" placeholder="BPM" class="bpm-input">
                    <select id="quantization-select" class="quant-select">
                        <option value="32" selected>1/32 (Í∏∞Î≥∏)</option>
                        <option value="64">1/64 (ÏÑ¨ÏÑ∏Ìï®)</option>
                        <option value="128">1/128 (Ï¥àÏ†ïÎ∞Ä)</option>
                        <option value="0">Î≥¥Ï†ï ÏóÜÏùå (Raw)</option>
                    </select>
                </div>

                <!-- Volume Controls -->
                <div class="control-row" style="margin-top: 10px; gap: 5px;">
                    <label style="font-size: 0.8rem; color: #ccc; align-self: center;">ÏùåÎüâ(0-15+):</label>
                    <input type="number" id="vol-melody" value="15" min="0" max="30" placeholder="Mel" class="bpm-input"
                        title="Î©úÎ°úÎîî ÏùåÎüâ (15 Ïù¥ÏÉÅÏùÄ Ï¶ùÌè≠)">
                    <input type="number" id="vol-harmony1" value="15" min="0" max="30" placeholder="H1"
                        class="bpm-input" title="ÌôîÏùå1 ÏùåÎüâ (15 Ïù¥ÏÉÅÏùÄ Ï¶ùÌè≠)">
                    <input type="number" id="vol-harmony2" value="15" min="0" max="30" placeholder="H2"
                        class="bpm-input" title="ÌôîÏùå2 ÏùåÎüâ (15 Ïù¥ÏÉÅÏùÄ Ï¶ùÌè≠)">
                </div>

                <!-- Noise Filter Controls -->
                <div class="control-row" style="margin-top: 10px; gap: 5px;">
                    <label style="font-size: 0.8rem; color: #ccc; align-self: center;">ÌïÑÌÑ∞:</label>
                    <input type="number" id="min-duration" value="50" min="0" max="500" placeholder="50ms"
                        class="bpm-input" title="ÏµúÏÜå Í∏∏Ïù¥(ms)">
                    <input type="number" id="min-velocity" value="10" min="0" max="100" placeholder="10%"
                        class="bpm-input" title="ÏµúÏÜå Í∞ïÎèÑ(%)">
                </div>

                <!-- MML Slicing Controls -->
                <div class="control-row" style="margin-top: 10px; gap: 5px;">
                    <label style="font-size: 0.8rem; color: #ccc; align-self: center;">MML Íµ¨Í∞Ñ:</label>
                    <input type="text" id="mml-start-time" placeholder="00:00" class="bpm-input" title="MML ÏãúÏûë ÏãúÍ∞Ñ">
                    <span style="color: #ccc; align-self: center;">~</span>
                    <input type="text" id="mml-end-time" placeholder="ÎÅùÍπåÏßÄ" class="bpm-input" title="MML Ï¢ÖÎ£å ÏãúÍ∞Ñ">
                </div>

                <!-- <div id="track-list" style="margin-top: 10px; margin-bottom: 15px;"></div> -->
                <div id="track-list" style="display: none;"></div>

                <button id="convert-btn" class="action-btn primary">Î≥ÄÌôòÌïòÍ∏∞</button>
            </div>

            <!-- Result Section -->
            <div id="result-section" style="display: none; margin-top: 20px;">
                <div id="error-display" class="error-banner" style="display: none;"></div>

                <!-- Melody Card -->
                <div class="mml-card">
                    <div class="card-header">
                        <div class="icon-label">
                            <div class="speaker-icon">üîä</div>
                            <span class="part-name">Î©úÎ°úÎîî</span>
                        </div>
                        <span class="char-count" id="count-melody">0/1200</span>
                    </div>
                    <div class="card-body">
                        <textarea id="mml-melody" readonly></textarea>
                        <button class="copy-btn" data-target="mml-melody">Î≥µÏÇ¨</button>
                    </div>
                </div>

                <!-- Harmony 1 Card -->
                <div class="mml-card">
                    <div class="card-header">
                        <div class="icon-label">
                            <div class="speaker-icon">üîä</div>
                            <span class="part-name">ÌôîÏùå 1</span>
                        </div>
                        <span class="char-count" id="count-harmony1">0/1200</span>
                    </div>
                    <div class="card-body">
                        <textarea id="mml-harmony1" readonly></textarea>
                        <button class="copy-btn" data-target="mml-harmony1">Î≥µÏÇ¨</button>
                    </div>
                </div>

                <!-- Harmony 2 Card -->
                <div class="mml-card">
                    <div class="card-header">
                        <div class="icon-label">
                            <div class="speaker-icon">üîä</div>
                            <span class="part-name">ÌôîÏùå 2</span>
                        </div>
                        <span class="char-count" id="count-harmony2">0/1200</span>
                    </div>
                    <div class="card-body">
                        <textarea id="mml-harmony2" readonly></textarea>
                        <button class="copy-btn" data-target="mml-harmony2">Î≥µÏÇ¨</button>
                    </div>
                </div>
            </div>
        </main>

        <!-- Bottom Bar -->
        <div class="bottom-bar">
            <div class="bottom-content">
                <p class="ai-credit">Powered by Antigravity</p>
                <button id="create-song-btn" class="create-btn">Ï†ÑÏ≤¥ Î≥µÏÇ¨</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1/dist/magentamusic.min.js"></script>
    <script>
        // Mabinogi MML Converter Logic

        // Constants for Mabinogi MML
        const MML_NOTES = ['c', 'c+', 'd', 'd+', 'e', 'f', 'f+', 'g', 'g+', 'a', 'a+', 'b'];
        const MAX_VOLUME = 15; // Mabinogi volume is usually 0-15
        const DEFAULT_OCTAVE = 4;
        const DEFAULT_LENGTH = 4; // l4

        let currentMidi = null;
        let selectedFile = null;

        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('midi-input');
            const fileNameDisplay = document.getElementById('file-name');
            const controlsSection = document.getElementById('controls');
            const resultSection = document.getElementById('result-section');
            const trackList = document.getElementById('track-list');
            const convertBtn = document.getElementById('convert-btn');
            const startAnalysisBtn = document.getElementById('start-analysis-btn');

            // File Upload Handling
            dropZone.addEventListener('click', () => fileInput.click());

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = '#fff';
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.style.borderColor = 'var(--primary-color)';
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = 'var(--primary-color)';
                if (e.dataTransfer.files.length) {
                    selectedFile = e.dataTransfer.files[0];
                    fileNameDisplay.textContent = selectedFile.name;
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    selectedFile = e.target.files[0];
                    fileNameDisplay.textContent = selectedFile.name;
                    document.getElementById('song-title').value = selectedFile.name.replace(/\.[^/.]+$/, "");
                }
            });

            startAnalysisBtn.addEventListener('click', () => {
                if (selectedFile) {
                    handleFile(selectedFile);
                } else {
                    alert("Î®ºÏ†Ä ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.");
                }
            });

            // Time Input Masking (mm:ss)
            const timeInputs = [
                document.getElementById('start-time'),
                document.getElementById('end-time'),
                document.getElementById('mml-start-time'),
                document.getElementById('mml-end-time')
            ];
            timeInputs.forEach(input => {
                input.addEventListener('input', (e) => {
                    let value = e.target.value.replace(/\D/g, ''); // Remove non-digits
                    if (value.length >= 3) {
                        value = value.slice(0, 2) + ':' + value.slice(2, 4);
                    }
                    e.target.value = value;
                });
            });

            function parseTime(timeStr) {
                if (!timeStr || !timeStr.includes(':')) return null;
                const parts = timeStr.split(':');
                const min = parseInt(parts[0]) || 0;
                const sec = parseInt(parts[1]) || 0;
                return min * 60 + sec;
            }

            function formatTime(seconds) {
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }

            async function handleFile(file) {
                fileNameDisplay.textContent = file.name;
                const loadingOverlay = document.getElementById('loading-overlay');
                const loadingText = document.getElementById('loading-text');
                const progressBar = document.getElementById('progress-bar');
                const progressPercent = document.getElementById('progress-percent');

                const setProgress = (percent, msg) => {
                    progressBar.style.width = `${percent}%`;
                    progressPercent.textContent = `${percent}%`;
                    if (msg) loadingText.textContent = msg;
                };

                try {
                    if (file.name.match(/\.(mid|midi)$/i)) {
                        // Handle MIDI
                        const arrayBuffer = await file.arrayBuffer();
                        currentMidi = new Midi(arrayBuffer);
                        processMidiLoaded();
                    } else if (file.name.match(/\.(mp3|wav|ogg|mp4)$/i)) {
                        // Handle Audio (MP3/WAV/MP4) with Chunking
                        loadingOverlay.style.display = 'flex';
                        setProgress(0, "Ï§ÄÎπÑ Ï§ë...");

                        // 1. Initialize Model
                        setProgress(5, "AI Î™®Îç∏ Î°úÎî© Ï§ë...");
                        const model = new mm.OnsetsAndFrames('https://storage.googleapis.com/magentadata/js/checkpoints/transcription/onsets_frames_uni');
                        await model.initialize();
                        setProgress(15, "Ïò§ÎîîÏò§ ÎîîÏΩîÎî© Ï§ë...");

                        // 2. Decode Audio
                        const arrayBuffer = await file.arrayBuffer();
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const originalBuffer = await audioContext.decodeAudioData(arrayBuffer);

                        // --- Optimization: Slice BEFORE Resampling ---
                        // Parse User Range immediately
                        const userStart = parseTime(document.getElementById('start-time').value);
                        const userEnd = parseTime(document.getElementById('end-time').value);
                        const totalDuration = originalBuffer.duration;

                        const effectiveStart = (userStart !== null && userStart < totalDuration) ? userStart : 0;
                        const effectiveEnd = (userEnd !== null && userEnd > effectiveStart && userEnd <= totalDuration) ? userEnd : totalDuration;

                        // Slice the buffer
                        const slicedBuffer = sliceAudioBuffer(audioContext, originalBuffer, effectiveStart, effectiveEnd);

                        // --- Optimization: Resample to 16kHz (Only the sliced part) ---
                        setProgress(18, "Ïò§ÎîîÏò§ ÏµúÏ†ÅÌôî Ï§ë (16kHz Î¶¨ÏÉòÌîåÎßÅ)...");
                        const audioBuffer = await resampleTo16k(slicedBuffer);

                        // 3. Chunking & Transcription
                        const CHUNK_DURATION = 15;
                        // Now the audioBuffer is ALREADY the cut version, so duration is the cut length
                        const rangeDuration = audioBuffer.duration;
                        const totalChunks = Math.ceil(rangeDuration / CHUNK_DURATION);
                        let fullNotes = [];

                        setProgress(20, `Î≥ÄÌôò ÏãúÏûë... (${formatTime(effectiveStart)} ~ ${formatTime(effectiveEnd)})`);

                        for (let i = 0; i < totalChunks; i++) {
                            const startTime = i * CHUNK_DURATION; // Relative to the sliced buffer (starts at 0)
                            const endTime = Math.min(startTime + CHUNK_DURATION, rangeDuration);

                            // Create chunk buffer
                            const sampleRate = audioBuffer.sampleRate; // 16000
                            const startSample = Math.floor(startTime * sampleRate);
                            const endSample = Math.floor(endTime * sampleRate);
                            const frameCount = endSample - startSample;

                            if (frameCount <= 0) continue;

                            const chunkBuffer = audioContext.createBuffer(
                                audioBuffer.numberOfChannels,
                                frameCount,
                                sampleRate
                            );

                            // Copy data
                            for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                                const channelData = audioBuffer.getChannelData(ch).subarray(startSample, endSample);
                                chunkBuffer.copyToChannel(channelData, ch);
                            }

                            // Transcribe chunk
                            const ns = await model.transcribeFromAudioBuffer(chunkBuffer);

                            // Offset and merge notes
                            ns.notes.forEach(note => {
                                fullNotes.push({
                                    pitch: note.pitch,
                                    startTime: note.startTime + startTime, // Relative to sliced start
                                    endTime: note.endTime + startTime,
                                    velocity: note.velocity
                                });
                            });

                            // Update Progress
                            const percent = 20 + Math.round(((i + 1) / totalChunks) * 80);
                            setProgress(percent, `Î≥ÄÌôò Ï§ë... (${i + 1}/${totalChunks} Íµ¨Í∞Ñ ÏôÑÎ£å)`);
                        }

                        setProgress(100, "Î≥ÄÌôò ÏôÑÎ£å! ÎßàÎ¨¥Î¶¨ Ï§ë...");

                        // Notes are already relative to the start of the slice (0), so no offset needed.
                        const combinedNS = { notes: fullNotes };

                        // Convert NoteSequence to Tone.js Midi-like structure
                        currentMidi = convertNoteSequenceToMidiStruct(combinedNS);

                        loadingOverlay.style.display = 'none';
                        processMidiLoaded();

                    } else {
                        alert("ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌååÏùº ÌòïÏãùÏûÖÎãàÎã§.");
                    }
                } catch (err) {
                    console.error(err);
                    loadingOverlay.style.display = 'none';
                    alert("ÌååÏùº Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + err.message);
                }
            }

            function sliceAudioBuffer(context, buffer, start, end) {
                const rate = buffer.sampleRate;
                const startOffset = Math.floor(start * rate);
                const endOffset = Math.floor(end * rate);
                const frameCount = endOffset - startOffset;

                if (frameCount <= 0) return buffer;

                const newBuffer = context.createBuffer(buffer.numberOfChannels, frameCount, rate);
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    const channelData = buffer.getChannelData(i).subarray(startOffset, endOffset);
                    newBuffer.copyToChannel(channelData, i);
                }
                return newBuffer;
            }

            async function resampleTo16k(audioBuffer) {
                if (audioBuffer.sampleRate === 16000) return audioBuffer;

                const offlineCtx = new OfflineAudioContext(
                    audioBuffer.numberOfChannels,
                    audioBuffer.duration * 16000,
                    16000
                );

                const source = offlineCtx.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(offlineCtx.destination);
                source.start();

                return await offlineCtx.startRendering();
            }


            function convertNoteSequenceToMidiStruct(ns) {
                // Create a fake Midi structure compatible with our existing code
                const notes = ns.notes.map(n => ({
                    midi: n.pitch,
                    time: n.startTime,
                    duration: n.endTime - n.startTime,
                    velocity: n.velocity / 100 // Normalize to 0-1 roughly
                }));

                // Sort by time
                notes.sort((a, b) => a.time - b.time);

                return {
                    header: { tempos: [{ bpm: 120 }] }, // Default BPM, Magenta output is usually time-based
                    tracks: [
                        { name: "AI Transcribed Piano", notes: notes }
                    ]
                };
            }

            function processMidiLoaded() {
                console.log("MIDI Loaded:", currentMidi);

                // Auto-detect BPM
                const bpm = (currentMidi.header && currentMidi.header.tempos && currentMidi.header.tempos.length > 0)
                    ? Math.round(currentMidi.header.tempos[0].bpm)
                    : 120;
                document.getElementById('bpm-input').value = bpm;

                renderTrackList(currentMidi.tracks);
                controlsSection.style.display = 'block';
                resultSection.style.display = 'none';
                document.getElementById('error-display').style.display = 'none'; // Reset error display
            }

            function renderTrackList(tracks) {
                trackList.innerHTML = '';

                tracks.forEach((track, index) => {
                    if (track.notes.length === 0) return; // Skip empty tracks

                    const div = document.createElement('div');
                    div.className = 'track-item';

                    // Default all to "Include"
                    div.innerHTML = `
                        <span>Track ${index + 1}: ${track.name || 'Untitled'} (${track.notes.length} notes)</span>
                        <select data-track-index="${index}">
                            <option value="include" selected>Î≥ÄÌôò Ìè¨Ìï®</option>
                            <option value="none">ÏÇ¨Ïö© Ïïà Ìï®</option>
                        </select>
                    `;
                    trackList.appendChild(div);
                });
            }

            function updateResult(melody, harmony1, harmony2) {
                document.getElementById('mml-melody').value = melody;
                document.getElementById('mml-harmony1').value = harmony1;
                document.getElementById('mml-harmony2').value = harmony2;

                // Update Character Counts
                document.getElementById('count-melody').textContent = `${melody.length} / 1200`;
                document.getElementById('count-harmony1').textContent = `${harmony1.length} / 1200`;
                document.getElementById('count-harmony2').textContent = `${harmony2.length} / 1200`;

                // Color warning if > 1200
                [
                    { id: 'count-melody', len: melody.length },
                    { id: 'count-harmony1', len: harmony1.length },
                    { id: 'count-harmony2', len: harmony2.length }
                ].forEach(item => {
                    const el = document.getElementById(item.id);
                    if (item.len > 1200) {
                        el.style.color = 'red';
                        el.style.fontWeight = 'bold';
                    } else {
                        el.style.color = '#888';
                        el.style.fontWeight = 'normal';
                    }
                });

                resultSection.style.display = 'block';
            }

            convertBtn.addEventListener('click', () => {
                if (!currentMidi) return;

                const selects = trackList.querySelectorAll('select');
                let allNotes = [];
                let hasSelection = false;

                selects.forEach(select => {
                    if (select.value !== 'none') {
                        const trackIndex = parseInt(select.dataset.trackIndex);
                        const track = currentMidi.tracks[trackIndex];

                        // 1. Filter & Sanitize
                        // Read User Settings
                        const userMinDur = parseInt(document.getElementById('min-duration').value) || 50;
                        const userMinVel = parseInt(document.getElementById('min-velocity').value) || 10;

                        const MIN_DURATION = userMinDur / 1000; // ms to seconds
                        const MIN_VELOCITY = userMinVel / 100;  // % to 0-1

                        track.notes.forEach(note => {
                            const duration = parseFloat(note.duration) || 0;
                            const velocity = parseFloat(note.velocity) || 0;

                            // Filter noise (too short or too quiet)
                            if (duration < MIN_DURATION || velocity < MIN_VELOCITY) return;

                            allNotes.push({
                                ...note,
                                time: parseFloat(note.time) || 0,
                                duration: duration,
                                velocity: velocity,
                                originalTrack: trackIndex
                            });
                        });
                        hasSelection = true;
                    }
                });

                if (!hasSelection) {
                    alert("Î≥ÄÌôòÌï† Ìä∏ÎûôÏùÑ ÌïòÎÇò Ïù¥ÏÉÅ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.");
                    return;
                }

                // --- User Inputs ---
                // 1. BPM (User override or MIDI default)
                const userBpm = parseInt(document.getElementById('bpm-input').value) || 120;
                const midiBpm = (currentMidi && currentMidi.header && currentMidi.header.tempos && currentMidi.header.tempos.length > 0)
                    ? currentMidi.header.tempos[0].bpm
                    : 120;

                const bpm = userBpm;

                // 2. Quantization Level
                const quantizeVal = parseInt(document.getElementById('quantization-select').value);

                // --- Quantization & Error Calculation ---
                let totalError = 0;
                let noteCount = 0;

                if (quantizeVal > 0) {
                    // 60 / BPM = 1 Beat (1/4 note)
                    // 1/32 note = 1 Beat / 8
                    // 1/64 note = 1 Beat / 16
                    // 1/128 note = 1 Beat / 32
                    let div = 8;
                    if (quantizeVal === 64) div = 16;
                    if (quantizeVal === 128) div = 32;

                    const tickDuration = (60 / bpm) / div;

                    allNotes.forEach(note => {
                        const originalTime = note.time;

                        // Snap time
                        note.time = Math.round(note.time / tickDuration) * tickDuration;

                        // Snap duration (min 1 tick)
                        let quantizedDuration = Math.round(note.duration / tickDuration) * tickDuration;
                        if (quantizedDuration < tickDuration) quantizedDuration = tickDuration;
                        note.duration = quantizedDuration;

                        // Calculate Error (Time difference in ms)
                        totalError += Math.abs(note.time - originalTime);
                        noteCount++;
                    });
                }

                // Display Error
                const errorDisplay = document.getElementById('error-display');
                if (noteCount > 0) {
                    const avgErrorMs = (totalError / noteCount) * 1000;
                    if (avgErrorMs > 30) {
                        errorDisplay.style.display = 'block';
                        errorDisplay.textContent = `‚ö†Ô∏è ÌèâÍ∑† Î∞ïÏûê Ïò§Ï∞®: ${avgErrorMs.toFixed(1)}ms (BPMÏù¥ ÎßûÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§)`;
                    } else {
                        errorDisplay.style.display = 'block';
                        errorDisplay.style.color = '#4caf50'; // Green
                        errorDisplay.textContent = `‚úÖ ÌèâÍ∑† Î∞ïÏûê Ïò§Ï∞®: ${avgErrorMs.toFixed(1)}ms (ÏñëÌò∏)`;
                    }
                } else {
                    errorDisplay.style.display = 'none';
                }

                // 2. Sort: Time ASC -> Pitch DESC (Top-Note Priority)
                allNotes.sort((a, b) => {
                    if (Math.abs(a.time - b.time) < 0.0001) {
                        return b.midi - a.midi; // Higher pitch first (Melody Priority)
                    }
                    return a.time - b.time;
                });

                // --- MML Range Slicing ---
                const mmlStartStr = document.getElementById('mml-start-time').value;
                const mmlEndStr = document.getElementById('mml-end-time').value;

                let mmlStart = parseTime(mmlStartStr);
                let mmlEnd = parseTime(mmlEndStr);

                // If user didn't input, default to full range
                if (mmlStart === null) mmlStart = 0;
                if (mmlEnd === null) mmlEnd = 999999;

                // Filter notes within MML range
                allNotes = allNotes.filter(n => n.time >= mmlStart && n.time <= mmlEnd);

                // Shift times to start at 0
                if (allNotes.length > 0 && mmlStart > 0) {
                    allNotes.forEach(n => {
                        n.time -= mmlStart;
                    });
                }

                // 2.5 Legato Smoothing (Merge same-pitch notes that are close)
                const MERGE_THRESHOLD = 0.05; // 50ms gap allowed
                const mergedNotes = [];
                if (allNotes.length > 0) {
                    let current = allNotes[0];
                    for (let i = 1; i < allNotes.length; i++) {
                        const next = allNotes[i];
                        // Check if same pitch and close enough
                        if (current.midi === next.midi &&
                            (next.time - (current.time + current.duration)) < MERGE_THRESHOLD) {
                            // Merge
                            current.duration = (next.time + next.duration) - current.time;
                            // Keep higher velocity? or average? Let's keep max.
                            current.velocity = Math.max(current.velocity, next.velocity);
                        } else {
                            mergedNotes.push(current);
                            current = next;
                        }
                    }
                    mergedNotes.push(current);
                    allNotes = mergedNotes;
                }

                // Distribute to 3 lanes (Melody, Harm1, Harm2)
                const lanes = [
                    { name: 'melody', notes: [], endTime: 0 },
                    { name: 'harmony1', notes: [], endTime: 0 },
                    { name: 'harmony2', notes: [], endTime: 0 }
                ];

                let droppedCount = 0;
                const CHORD_THRESHOLD = 0.02; // Notes closer than 20ms are chords

                allNotes.forEach(note => {
                    // Safety check for time/duration
                    const nTime = parseFloat(note.time) || 0;
                    const nDuration = parseFloat(note.duration) || 0;

                    let assigned = false;

                    for (let i = 0; i < lanes.length; i++) {
                        const lane = lanes[i];
                        const lastNote = lane.notes.length > 0 ? lane.notes[lane.notes.length - 1] : null;

                        // Case 1: Empty Lane -> Assign
                        if (!lastNote) {
                            lane.notes.push({ ...note, time: nTime, duration: nDuration });
                            assigned = true;
                            break;
                        }

                        // Case 2: Chord (Starts at same time as last note) -> Skip this lane
                        if (Math.abs(nTime - lastNote.time) < CHORD_THRESHOLD) {
                            continue; // Try next lane
                        }

                        // Case 3: Legato / Sequence (Starts after last note)
                        // If overlap, truncate the previous note
                        if (nTime < lastNote.time + lastNote.duration) {
                            // Truncate last note
                            lastNote.duration = nTime - lastNote.time;
                            // Prevent zero/negative duration (shouldn't happen due to sort, but safety)
                            if (lastNote.duration < 0.01) lastNote.duration = 0.01;
                        }

                        // Assign new note
                        lane.notes.push({ ...note, time: nTime, duration: nDuration });
                        assigned = true;
                        break;
                    }

                    if (!assigned) droppedCount++;
                });

                // 3. Read Volume Settings
                const volMelody = parseInt(document.getElementById('vol-melody').value) || 15;
                const volHarmony1 = parseInt(document.getElementById('vol-harmony1').value) || 15;
                const volHarmony2 = parseInt(document.getElementById('vol-harmony2').value) || 15;

                const mmlOutput = {
                    melody: convertNotesToMML(lanes[0].notes, volMelody),
                    harmony1: convertNotesToMML(lanes[1].notes, volHarmony1),
                    harmony2: convertNotesToMML(lanes[2].notes, volHarmony2)
                };

                updateResult(mmlOutput.melody, mmlOutput.harmony1, mmlOutput.harmony2);
            });

            // Copy Buttons for individual textareas
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetId = btn.dataset.target;
                    const textarea = document.getElementById(targetId);
                    textarea.select();
                    document.execCommand('copy');
                    const originalText = btn.textContent;
                    btn.textContent = 'Î≥µÏÇ¨Îê®!';
                    setTimeout(() => btn.textContent = originalText, 2000);
                });
            });

            const createBtn = document.getElementById('create-song-btn');
            createBtn.addEventListener('click', () => {
                const m = document.getElementById('mml-melody').value;
                const h1 = document.getElementById('mml-harmony1').value;
                const h2 = document.getElementById('mml-harmony2').value;
                if (!m && !h1 && !h2) {
                    alert("Î≥ÄÌôòÎêú ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§.");
                    return;
                }
                const full = `MML@${m},${h1},${h2};`;
                navigator.clipboard.writeText(full).then(() => {
                    const original = createBtn.textContent;
                    createBtn.textContent = "Ï†ÑÏ≤¥ Î≥µÏÇ¨ ÏôÑÎ£å!";
                    setTimeout(() => createBtn.textContent = original, 2000);
                });
            });
        });

        // --- Core Conversion Logic ---

        function convertNotesToMML(allNotes, maxVolume = 15) {
            if (!allNotes || allNotes.length === 0) return "MML@;";

            // Sort by time (just in case)
            allNotes.sort((a, b) => a.time - b.time);

            if (allNotes.length === 0) return "MML@;";

            // Safe BPM access
            const bpm = (currentMidi && currentMidi.header && currentMidi.header.tempos && currentMidi.header.tempos.length > 0)
                ? currentMidi.header.tempos[0].bpm
                : 120;

            // --- Optimization: Find Best Default Length (l) ---
            const durationCounts = {};
            let maxCount = 0;
            let bestLength = "4"; // Default fallback

            allNotes.forEach(note => {
                const parts = getDurationParts(note.duration, bpm);
                if (parts.length > 0) {
                    const len = parts[0]; // Count the first part (main duration)
                    durationCounts[len] = (durationCounts[len] || 0) + 1;
                    if (durationCounts[len] > maxCount) {
                        maxCount = durationCounts[len];
                        bestLength = len;
                    }
                }
            });

            let mml = `MML@t${Math.round(bpm)}l${bestLength}`;
            let currentOctave = DEFAULT_OCTAVE;
            let currentVolume = -1; // Force initial volume set
            let currentTime = 0;

            allNotes.forEach((note, index) => {
                // 1. Handle Rests
                if (note.time > currentTime + 0.01) { // Tolerance
                    const restDuration = note.time - currentTime;
                    const restParts = getDurationParts(restDuration, bpm);
                    restParts.forEach(part => {
                        mml += "r" + (part === bestLength ? "" : part);
                    });
                }

                // 2. Handle Volume
                // Map velocity (0-1) to MML volume (0-maxVolume)
                // Mabinogi limit is 15. If maxVolume > 15, it acts as a boost/compressor.
                let vol = Math.round(note.velocity * maxVolume);
                if (vol > 15) vol = 15; // Clamp to Mabinogi limit
                if (vol < 0) vol = 0;

                if (vol !== currentVolume) {
                    mml += "v" + vol;
                    currentVolume = vol;
                }

                // 3. Handle Octave
                const targetOctave = Math.floor(note.midi / 12) - 1;
                if (targetOctave !== currentOctave) {
                    if (targetOctave > currentOctave) {
                        mml += ">".repeat(targetOctave - currentOctave);
                    } else {
                        mml += "<".repeat(currentOctave - targetOctave);
                    }
                    currentOctave = targetOctave;
                }

                // 3. Handle Note
                const noteName = MML_NOTES[note.midi % 12];
                const durationParts = getDurationParts(note.duration, bpm);

                if (durationParts.length > 0) {
                    // First part: check against default length
                    const firstPart = durationParts[0];
                    mml += noteName + (firstPart === bestLength ? "" : firstPart);

                    // Tied parts
                    for (let i = 1; i < durationParts.length; i++) {
                        const part = durationParts[i];
                        mml += "&" + noteName + (part === bestLength ? "" : part);
                    }
                }

                currentTime = note.time + note.duration;
            });

            mml += ";";
            return mml;
        }

        function getDurationParts(seconds, bpm) {
            const beatDuration = 60 / bpm;
            const wholeNoteDuration = beatDuration * 4;

            // Convert to 64th note ticks (Mabinogi smallest unit usually)
            // 64th note duration = wholeNoteDuration / 64
            const tickDuration = wholeNoteDuration / 64;
            let ticks = Math.round(seconds / tickDuration);

            if (ticks <= 0) return [];

            const lengthMap = [
                { val: 64, mml: "1" },
                { val: 48, mml: "2." },
                { val: 32, mml: "2" },
                { val: 24, mml: "4." },
                { val: 16, mml: "4" },
                { val: 12, mml: "8." },
                { val: 8, mml: "8" },
                { val: 6, mml: "16." },
                { val: 4, mml: "16" },
                { val: 3, mml: "32." },
                { val: 2, mml: "32" },
                { val: 1, mml: "64" }
            ];

            let parts = [];

            while (ticks > 0) {
                let found = false;
                for (let i = 0; i < lengthMap.length; i++) {
                    if (ticks >= lengthMap[i].val) {
                        parts.push(lengthMap[i].mml);
                        ticks -= lengthMap[i].val;
                        found = true;
                        break;
                    }
                }
                if (!found) break;
            }

            return parts;
        }
    </script>
</body>

</html>